% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NCA_Server.R
\name{span_table}
\alias{span_table}
\title{Spread Large Table Over Smaller Tables}
\usage{
span_table(
  table_body = NULL,
  row_common = NULL,
  table_body_head = NULL,
  row_common_head = NULL,
  header_format = "text",
  obnd = NULL,
  max_row = 20,
  max_col = 10,
  max_height = 7,
  max_width = 6.5,
  table_alignment = "center",
  inner_border = officer::fp_border(color = "black", width = 0.3),
  outer_border = officer::fp_border(color = "black", width = 2),
  set_header_inner_border_v = TRUE,
  set_header_inner_border_h = TRUE,
  set_header_outer_border = TRUE,
  set_body_inner_border_v = TRUE,
  set_body_inner_border_h = FALSE,
  set_body_outer_border = TRUE,
  notes_detect = NULL
)
}
\arguments{
\item{table_body}{Data frame with the body of the large table.}

\item{row_common}{Data frame with the common rows.}

\item{table_body_head}{Data frame or matrix with headers for the table body.}

\item{row_common_head}{Data frame or matrix with headers for the common rows.}

\item{header_format}{Format of the header either \code{"text"} (default) or \code{"md"} for markdown.}

\item{obnd}{Optional onbrand object used to format markdown. The default \code{NULL} value will use default formatting.}

\item{max_row}{Maximum number of rows in output tables (A value of \code{NULL} will set max_row to the number of rows in the table).}

\item{max_col}{Maximum number of columns in output tables (A value of \code{NULL} will set max_col to number of columns in the table).}

\item{max_height}{Maximum height of the final table in inches (A value of \code{NULL} will use 100 inches).}

\item{max_width}{Maximum width of the final table in inches (A value of \code{NULL} will use 100 inches).}

\item{table_alignment}{Character string specifying the alignment #'of the table (body and headers). Can be \code{"center"} (default), \code{"left"}, \code{"right"}, or \code{"justify"}}

\item{inner_border}{Border object for inner border lines defined using \code{officer::fp_border()}}

\item{outer_border}{Border object for outer border lines defined using \code{officer::fp_border()}}

\item{set_header_inner_border_v}{Boolean value to enable or disable inner vertical borders for headers}

\item{set_header_inner_border_h}{Boolean value to enable or disable inner horizontal borders for headers}

\item{set_header_outer_border}{Boolean value to enable or disable outer border for headers}

\item{set_body_inner_border_v}{Boolean value to enable or disable inner vertical borders for the body}

\item{set_body_inner_border_h}{Boolean value to enable or disable inner horizontal borders for the body}

\item{set_body_outer_border}{Boolean value to enable or disable outer border borders for the body}

\item{notes_detect}{Vector of strings to detect in output tables (example \code{c("NC", "BLQ")}).}
}
\value{
list with the following elements
\itemize{
\item{isgood:} Boolean indicating the exit status of the function.
\item{msgs:}   Vector of text messages describing any errors that were found.
\item{tables:} Named list of tables. Each list element is of the output
format from \code{build_span()}.
}
}
\description{
Takes a large table and spreads it over smaller tables to
paginate it. It will preserve common row  information on the left and
separate columns according to maximum specifications. The final tables will
have widths less than or equal to both max_col and max_width, and heights
less than or equal to both max_row and max_height.
}
\details{
The way the data frames relate to each other are mapped out below. The
dimensions of the different data frames are identified below (nrow x ncol)

\if{html}{\out{<div class="sourceCode">}}\preformatted{#|-------------------------------------| ---
#|                 |                   |  ^
#|                 |                   |  |
#| row_common_head |  table_body_head  |  | m
#|      m x n      |       m x c       |  |
#|                 |                   |  v
#|-------------------------------------| ---
#|                 |                   |  ^
#|                 |                   |  |
#|    row_common   |    table_body     |  | r
#|      r x n      |      r x c        |  |
#|                 |                   |  |
#|                 |                   |  v
#|-------------------------------------| ---
#
#|<--------------->|<----------------->|
#        n                   c
}\if{html}{\out{</div>}}
}
\examples{
library(formods)
library(readxl)
library(dplyr)
library(tidyr)

# First we need to create some data. 
# This will read in a test dataset:
DS = readxl::read_excel(
 path  = system.file(package="formods", 
                     "test_data", 
                     "TEST_DATA.xlsx"),
 sheet = "DATA")

# This will filter the dataset down and modify the formatting
DS = dplyr::filter(DS, EVID == 0)                          |>
  dplyr::filter(ID <= 30)                                  |>
  dplyr::select(ID, TIME, DV, CMT)                         |>
  dplyr::mutate(CMT  = ifelse(.data[["CMT"]] == "C_ng_ml", 
                             "Test Article", 
                             .data[["CMT"]]))              |>
  dplyr::select(ID, TIME, DV, CMT)                         |>
  dplyr::mutate(CMT = ifelse(.data[["CMT"]] == "BM_ng_ml", 
                            "Biomarker", 
                            .data[["CMT"]]))               |>
  dplyr::rename(Analyte = "CMT")                           |>
  dplyr::mutate(DV = ifelse(.data[["DV"]] == 0, "BQL", .data[["DV"]]))

# This represents the large table we want to split up into smaller tables 
wide_df = tidyr::pivot_wider(DS,
  values_from = "DV",
  names_from  = "ID")               |>
  dplyr::arrange(Analyte, TIME)     |>
  dplyr::mutate(TIME = as.character(.data[["TIME"]]))    

# The first two columns represent the rows
# that are common across the tables:
row_common = wide_df[,1:2]

# The remaining columns represent the body of the table:
table_body = wide_df[,3:ncol(wide_df)]

# Next we create matrices that contain the header 
# information for each component above:
row_common_head = matrix(
  data  = c("Time", "Analyte",
            "(hr)", "(ng/ml)"),
  ncol  = 2,
  byrow = TRUE)

table_body_head = matrix(
  data  = c(rep("Subject ID", times=ncol(table_body)), 
            names(table_body)),
  ncol  = ncol(table_body),
  byrow = TRUE)


# This builds all of the tables:
span_res = span_table(table_body      = table_body,
                      row_common      = row_common,
                      table_body_head = table_body_head,
                      row_common_head = row_common_head,
                      notes_detect    = c("BQL"))

# This will show you the first one:
span_res$tables[["Table 1"]]$ft

# This will build a single table with the rows and 
# column ranges specified
bs_res =   build_span(table_body      = table_body,
                      row_common      = row_common,
                      table_body_head = table_body_head,
                      row_common_head = row_common_head,
                      col_sel         = c(1:10),
                      row_sel         = c(1:10),
                      notes_detect    = c("BQL"))

# This will show you the result:
bs_res$ft
}
\seealso{
\code{\link{build_span} for the relationship of inputs.}
}
