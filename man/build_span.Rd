% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NCA_Server.R
\name{build_span}
\alias{build_span}
\title{Spread Large Table Over Smaller Tables}
\usage{
build_span(
  table_body = NULL,
  row_common = NULL,
  table_body_head = NULL,
  row_common_head = NULL,
  header_format = "text",
  obnd = NULL,
  row_sel = NULL,
  col_sel = NULL,
  table_alignment = "center",
  inner_border = officer::fp_border(color = "black", width = 0.3),
  outer_border = officer::fp_border(color = "black", width = 2),
  set_header_inner_border_v = TRUE,
  set_header_inner_border_h = TRUE,
  set_header_outer_border = TRUE,
  set_body_inner_border_v = TRUE,
  set_body_inner_border_h = FALSE,
  set_body_outer_border = TRUE,
  notes_detect = NULL
)
}
\arguments{
\item{table_body}{Data frame with the body of the large table.}

\item{row_common}{Data frame with the common rows.}

\item{table_body_head}{Data frame or matrix with headers for the table body.}

\item{row_common_head}{Data frame or matrix with headers for the common rows.}

\item{header_format}{Format of the header either \code{"text"} (default) or \code{"md"} for markdown.}

\item{obnd}{Optional onbrand object used to format markdown. The default \code{NULL} value will use default formatting.}

\item{row_sel}{Indices of rows to build to the table with.}

\item{col_sel}{Indices of columns to build to the table with.}

\item{table_alignment}{Character string specifying the alignment #'of the table (body and headers). Can be \code{"center"} (default), \code{"left"}, \code{"right"}, or \code{"justify"}}

\item{inner_border}{Border object for inner border lines defined using \code{officer::fp_border()}}

\item{outer_border}{Border object for outer border lines defined using \code{officer::fp_border()}}

\item{set_header_inner_border_v}{Boolean value to enable or disable inner vertical borders for headers}

\item{set_header_inner_border_h}{Boolean value to enable or disable inner horizontal borders for headers}

\item{set_header_outer_border}{Boolean value to enable or disable outer border for headers}

\item{set_body_inner_border_v}{Boolean value to enable or disable inner vertical borders for the body}

\item{set_body_inner_border_h}{Boolean value to enable or disable inner horizontal borders for the body}

\item{set_body_outer_border}{Boolean value to enable or disable outer border borders for the body}

\item{notes_detect}{Vector of strings to detect in output tables (example \code{c("NC", "BLQ")}).}
}
\value{
list with the following elements
\itemize{
\item{df:}     Data frame with the built table.
\item{ft:}     The data frame as a flextable object.
\item{notes:}  Note placeholders found in the table.
}
}
\description{
Takes a large table and spreads it over smaller tables to
paginate it. It will preserve common row  information on the left and
separate columns according to maximum specifications.
}
\details{
The way the data frames relate to each other are mapped out below. The
dimensions of the different data frames are identified below (nrow x ncol)

\if{html}{\out{<div class="sourceCode">}}\preformatted{#                            col_sel
#                      |<--------------->|
#
#|--------------------------------------------| ---
#|                 |   .                 .    |  ^
#|                 |   .                 .    |  |
#| row_common_head |   . table_body_head .    |  | m
#|      m x n      |   .      m x c      .    |  |
#|                 |   .                 .    |  v
#|--------------------------------------------| ---
#|                 |   .                 .    |  ^
#|                 |   .                 .    |  |
#|    row_common   |   .   table_body    .    |  |
#|      r x n      |   .     r x c       .    |  |
#|                 |   .                 .    |  |
#|.................|..........................|  |     -
#|                 |   ./  /  /  /  /  / .    |  |     ^
#|                 |   .  /  /  /  /  /  .    |  | r   |
#|                 |   . /  /  /  /  /  /.    |  |     | row_sel
#|                 |   ./  /  /  /  /  / .    |  |     |
#|                 |   .  /  /  /  /  /  .    |  |     v
#|.................|...../../../../../../.... |  |     -
#|                 |   .                 .    |  |
#|                 |   .                 .    |  v
#|--------------------------------------------| ---
#
#|<--------------->|<------------------------>|
#        n                    c
}\if{html}{\out{</div>}}
}
\examples{
library(formods)
library(readxl)
library(dplyr)
library(tidyr)

# First we need to create some data. 
# This will read in a test dataset:
DS = readxl::read_excel(
 path  = system.file(package="formods", 
                     "test_data", 
                     "TEST_DATA.xlsx"),
 sheet = "DATA")

# This will filter the dataset down and modify the formatting
DS = dplyr::filter(DS, EVID == 0)                          |>
  dplyr::filter(ID <= 30)                                  |>
  dplyr::select(ID, TIME, DV, CMT)                         |>
  dplyr::mutate(CMT  = ifelse(.data[["CMT"]] == "C_ng_ml", 
                             "Test Article", 
                             .data[["CMT"]]))              |>
  dplyr::select(ID, TIME, DV, CMT)                         |>
  dplyr::mutate(CMT = ifelse(.data[["CMT"]] == "BM_ng_ml", 
                            "Biomarker", 
                            .data[["CMT"]]))               |>
  dplyr::rename(Analyte = "CMT")                           |>
  dplyr::mutate(DV = ifelse(.data[["DV"]] == 0, "BQL", .data[["DV"]]))

# This represents the large table we want to split up into smaller tables 
wide_df = tidyr::pivot_wider(DS,
  values_from = "DV",
  names_from  = "ID")               |>
  dplyr::arrange(Analyte, TIME)     |>
  dplyr::mutate(TIME = as.character(.data[["TIME"]]))    

# The first two columns represent the rows
# that are common across the tables:
row_common = wide_df[,1:2]

# The remaining columns represent the body of the table:
table_body = wide_df[,3:ncol(wide_df)]

# Next we create matrices that contain the header 
# information for each component above:
row_common_head = matrix(
  data  = c("Time", "Analyte",
            "(hr)", "(ng/ml)"),
  ncol  = 2,
  byrow = TRUE)

table_body_head = matrix(
  data  = c(rep("Subject ID", times=ncol(table_body)), 
            names(table_body)),
  ncol  = ncol(table_body),
  byrow = TRUE)


# This builds all of the tables:
span_res = span_table(table_body      = table_body,
                      row_common      = row_common,
                      table_body_head = table_body_head,
                      row_common_head = row_common_head,
                      notes_detect    = c("BQL"))

# This will show you the first one:
span_res$tables[["Table 1"]]$ft

# This will build a single table with the rows and 
# column ranges specified
bs_res =   build_span(table_body      = table_body,
                      row_common      = row_common,
                      table_body_head = table_body_head,
                      row_common_head = row_common_head,
                      col_sel         = c(1:10),
                      row_sel         = c(1:10),
                      notes_detect    = c("BQL"))

# This will show you the result:
bs_res$ft
}
